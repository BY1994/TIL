# 2021-04-15 (Number Theory for Exam)

알고리즘 시험에 나오는 정수론

### 1. 유클리트 호제법

유클리드 호제법을 이용해 최대공약수를 구하는건 약 O(log a)만큼의 시간이 걸림. long long 범위 안쪽의 어떤 수가 들어와도 60번 정도의 연산만 하면 최대공약수를 구할 수 있다.

```c
// a와 b 최대 공약수 구하는 일반 버전 O(b)
for(i = 1; i <= b; i++)
{
    if(a % i == 0 && b % i == 0)
    gcd = i;
}

// 유클리드 호제법 O(log a)
while(a % b != 0)
{
   temp = a % b;
   a = b;
   b = temp;
}

gcd = b;
```



### 2. n의 약수 구하기

```c
// 기본 방법 O(n)
for(i = 1; i <= n; i++)
{
    if(n % i == 0) print(i);
}

// Root(n) 시간
for(i=1; i * i <= n; i++)
{
    if(n % i == 0)
    {
        print(i);
        if(i * i != n) print(n / i);
    }
}
```



### 3. 모듈러 연산의 특징

(a + b) % c = (a % c + b % c) % c

자료형에서 오버 플로우가 나는 경우가 있다. (특히 dp 에서 많이 난다고 한다)

나눈 나머지를 구해야한다면 마지막에 하지 않고 중간 과정마다도 계속 모듈러 연산을 해도 결과는 같다.



### 4. 에라토스테네스의 체

어떤 수가 소수인지 아닌지 판별을 여러 번 해야할 때 사용



### 5. 소인수분해

약수 구하기와 유사한 방식으로 빠르게 구할 수 있다.
추가로, 모든 수는 소인수를 log개 이하로 갖고 있다. 가장 작은 소수가 2이기 때문에 당연한 이야기라고 한다. (이게 왜 log로 되는 것인지는 설명이 없는데 이해가 되지 않는다)



### 6. 빠른 거듭제곱

분할정복을 이용해 a의 b제곱을 log b 시간에 구할 수 있다고 한다.



[출처] https://kau-algorithm.tistory.com/27