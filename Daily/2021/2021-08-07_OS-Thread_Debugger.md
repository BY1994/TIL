# 2021-08-07 (OS - Thread, Debugger)

고급 개발자들만이 알고 있던 OS 제작의 원리 그리고 Codes, 오재준 저, 가남사

도서를 읽고 정리하고 싶은 내용들

### 프로세스와 스레드

프로세스와 스레드

> 프로세스는 완전한 하나의 독립적 실행 단위이다. 독립적이라는 말의 의미는 프로세스가 각자 별개의 주소 공간 상에서 실행되기 때문에 일반적인 접근 방식을 통해 다른 프로세스에 영향을 주거나 영향을 받지 않는다는 것이다 (물론 다른 프로세스로부터 영향을 주거나 영향을 받지 않는지의 여부는 프로세스의 메모리 모델을 어떤 것으로 설정하느냐에 달린 것이다). 그렇기 때문에 프로세스 관리는 메모리 관리 메커니즘 (Mechanism) 과도 밀접한 관련을 갖는다. 현재 Bellona2 커널에서 사용되고 있는 메모리 모델은 가상 페이지형 플랫 (Virtual-Paged Flat) 이다. 이것은 프로세스별로 4기가바이트에 달하는 가상 메모리를 가질 수 있는 모델이다. 프로세스의 주소 공간이 서로 다르기 때문에 잘못된 프로세스가 전체 시스템에 나쁜 영향을 미칠 가능성은 줄어들지만 프로세스 간에 데이터를 전달하는 데에는 약간의 번거로움이 따른다. 서로 다른 주소 공간을 갖기 때문에 단순히 주소 값을 전달하여 포인터를 통해 다른 프로세스의 영역을 액세스하는 것은 불가능하다. 이렇게 하려면 먼저 공유 메모리를 설정하여야 한다. 
>
> 프로세스와 아울러 고려하여야 할 부분은 쓰레드 (Thread)이다. 프로세스를 설명할 때 완전한 하나의 독립적 실행 단위라는 말을 썼다. 완전하다는 의미는 그 자체로서 어떠한 일을 수행하는데 추가적으로 필요한 부분이 없다는 것을 의미한다. 프로세스가 완전한 하나의 독립 실행 단위라면 쓰레드는 프로세스에 의존적이다. 프로세스가 텍스트, 데이터, 스택을 포함하여 실행에 필요한 주소 공간과 컨텍스트를 가지고 있는 것에 비해 쓰레드에는 주소 공간이 포함되지 않는다. 대신 자신이 소속된 프로세스의 주소 공간을 다른 쓰레드들과 공유한다.
>
> 프로세스를 통해 CPU가 어떠한 일을 수행하고자 할 때 필요한 것들이 무엇인지 생각해 보자. 우선 메모리가 필요할 것이다. 메모리에는 CPU가 실행할 수 있는 실행 코드와 그것에 의해 다루어질 수 있는 데이터 그리고 스택이 포함된다. 그 외에 프로세스가 실행되고 있는 시점의 상태가 있다. 이것을 지칭할 때 별도로 컨텍스트 (Context) 혹은 문맥이라는 용어를 이용하는데 작게는 CPU 레지스터 값으로 볼 수도 있고 크게는 프로세스의 총체적이로고도 순간적인 상태라고 볼 수도 있다. 프로세스와 관련하여 자원을 포함한 주소 공간을 프로세스가 실행되기 위한 정적 요소라 본다면 컨텍스트는 프로세스의 동적 요소이다. 쓰레드는 프로세스의 동적 요소와 스택으로 이루어진다.
>
> 하나의 프로세스는 여러 쓰레드를 포함할 수 있다. 전통적인 유닉스의 프로세스는 하나의 쓰레드를 갖는 모델이다. 프로세스가 하나의 쓰레드를 갖는 모델보다 멀티쓰레드 (다중쓰레드) 를 지원하는 프로세스 모델이 훨씬 복잡하고 고려해야할 사항도 많다. Bellona2 커널의 원형이라고 할 수 있는 Bellona에서는 쓰레드를 고려하지 않았다. 프로세스가 가장 기본적인 작업 단위이며 스케줄링의 대상이었다. 단일쓰레드 모델을 이용한 프로세스 관리 부분이 거의 구현되었을 때쯤 Bellona 커널에 멀티쓰레드 개념을 추가하려고 하였는데 그때는 이미 프로세스 시스템이 커널의 다른 부분과 너무 깊이 관여되어 있었기 때문에 멀티쓰레드 개념을 적용할 수 없었다. Bellona2 커널에서는 물론 멀티쓰레드를 지원한다. 하나의 프로세스 내에 여러 개의 쓰레드를 생성할 수 있다. 쓰레드들은 프로세스의 소유로 인식되며 프로세스의 주소 공간을 경유한다. 프로세들은 서로 다른 주소 공간에서 작동되기 때문에 임의대로 다른 프로세스의 영역을 침범할 수 없지만 하나의 프로세스 내에 존재하는 쓰레드들은 같은 주소 공간을 공유하기 때문에 이들은 얼마든지 다른 쓰레드에 영향을 줄 수 있다. 동일 프로세스 내의 쓰레드 간 데이터 공유는 아주 간단하다.

스케줄링

> 스케줄링이란 스케줄러가 준비 (Ready) 상태에 있는 쓰레드들 가운데 하나를 선택하여 CPU로 하여금 실행하도록 하는 것을 의미한다. 여러 개의 스케줄링 대상이 존재할 때 언제 어느 것을 선택하여 스케줄링 할 것인지의 여부는 어떤 스케줄링 정책을 적용하느냐에 따라 다르며 그에 따라 시스템의 성능 차이도 발생하게 된다.

쓰레드

> Bellona2 에서의 쓰레드는 "최소한의 작업 단위", "스케줄링의 대상"으로 표현할 수 있다. 쓰레드는 프로세스에 비해 생성하는 것에 따르는 부담이 적고 동일 프로세스 내의 쓰레드 간에 데이터 공유가 용이하다는 장점을 갖는다. 또한 프로세를 통해 처리하고자 하는 작업을 몇 개의 작은 작업으로 세분하여 쓰레드로 처리하도록 하면 개념적으로 보다 구조화된 프로그램 개발이 가능하다.

스케줄링 얘기를 할 때 프로세스 얘기는 나오지 않고 스레드만 나오는 것이 왜일까 싶었는데, 스케줄링의 대상이 프로세스가 아닌 스레드였다. 운영체제에 따라 다 멀티 스레드를 지워하는 게 아니니까 프로세스와 스레드가 거의 경계가 없었을 수도 있을 것 같다. LK 코드를 보다가 이런 궁금증이 생겼던 건데, 그 코드는 아예 스레드를 생성하고 스레드만 스케줄링한다.



### 디버거

하드웨어적으로 디버깅이 지원되는데, 디버그 레지스터와 디버그 인터럽트가 있다. 디버그 레지스터에는 하드웨어 브레이크 포인트 주소를 저장하는데 사용할 수 있다. 디버그 인터럽트 1번은 설정해두면 하나의 명령을 실행할 때마다 1번 인터럽트가 발생한다. 3번은 프로그램이 실행되다가 0XCCh (INT 3) 명령을 만나면 인터럽트 3번이 발생한다. 소프트웨어 브레이크 포인트 용도로 사용할 수 있다. 하드웨어 브레이크 포인트는 4개 제한이 있어서, 더 많은 브레이크 포인트가 필요하면 INT 3 명령을 사용해야한다. INT 3 명령은 어셈블 했을 때 0xCC 한 바이트로 번역된다. 인터럽트 3번에는 이렇게 별도의 명령 코드를 할당해주었다. (0xCCh는 무엇인지 모르겠다)



하드웨어 브레이크 포인트는 DR0, DR1, DR2, DR3 레지스터에 브레이크 포인트 주소를 설정해주면 된다. 액세스 방법 (읽기, 쓰기, 실행) 도 설정한다.



소프트웨어 인터럽트는 소스 코드 위치에 있던 소스 코드를 저장해두고, 실제 자리에는 0xCC로 대체해둔다. 그러면 실행될 때 인터럽트 3번이 뜨게 된다. 그 후에 원래 소스코드로 복구해준다. 



역어셈블 기능을 넣어서 16진수 기계어 코드를 사람이 알아볼 수 있게 어셈블리 명령어로 해석해서 보여준다. 디버거의 주요 기능이 역어셈블 기능에 의존하기 위해서 디버거를 만들려면 역어셈블 기능도 구현해야한다고 한다. (반대인 어셈블 기능도 만들어준다.)